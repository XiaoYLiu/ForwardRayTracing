program main


use parameters
use constants
use tensors


implicit none 
real(kind=dp) r,theta, phi

real(kind=dp), dimension(3) :: xi !radiation point w.r.t COM
real(kind=dp), dimension(3) :: xR !radiation point w.r.t BH
real(kind=dp), dimension(3) :: ki, ki_cartesian
real(kind=dp) x, y, z, t, mm
real(kind=dp) Ry_x, Ry_y, Ry_z
real(kind=dp) Rz_x, Rz_y, Rz_z

real(kind=dp), dimension(4) :: u_covar, u_contra !emitter velocity
real(kind=dp), dimension(4,4) :: metric_contra, transform, metric_covar, transform_to
real(kind=dp) :: N1, N2, N3, delta
real(kind=dp),dimension(4) :: k, kp, k_contra, k_covar
real(kind=dp), dimension(4) :: k_contra_global, k_covar_global
real(kind=dp) :: mag1, mag2, cpt, sigma, summation


integer(kind=dp)  :: ii, jj, kk
real(kind=dp) :: u0,u1,u2,u3, grr, gthth
real(kind=dp) :: u0_covar,u1_covar,u2_covar,u3_covar
real(kind=dp), dimension(4,4) :: Bmatrix
real(kind=dp), dimension(3,3) :: Ry, Rz
! Beam direction in local frame
ki(1) = 1
ki(2) = psi
ki(3) = chi

ki_cartesian(1) = sin(psi)*cos(chi)
ki_cartesian(2) = sin(psi)*sin(chi)
ki_cartesian(3) = cos(psi)

!Define PSR location in global coordinate frame
r = 50.0_dp
theta = PI/2.0_dp
phi = 0.0_dp



!And transform to Caresian coords
mm = sqrt(r**2 + a**2)
xi(1) = mm * sin(theta)*cos(phi)
xi(2) = mm * sin(theta)*sin(phi)
xi(3) = mm * cos(theta)


!Rotation
Ry = 0.0_dp
Rz = 0.0_dp

Ry(1,1) = cos(stheta)
Ry(1,3) = sin(stheta)
Ry(2,2) = 1.0_dp
Ry(3,1) = -sin(stheta)
Ry(3,3) = cos(stheta)

Rz(1,1) = cos(sphi)
Rz(1,2) = -sin(sphi)
Rz(2,1) = sin(sphi)
Rz(2,2) = cos(sphi)
Rz(3,3) = 1.0_dp


!No translation - is this ok?
ki_cartesian = MATMUL(Rz , MATMUL(Ry,ki_cartesian) )



!And switch back to BL coordinates
ki(1) = sqrt(ki_cartesian(1)**2 + ki_cartesian(2)**2 + ki_cartesian(3)**2)
ki(2) = acos(ki_cartesian(3) / ki(1))
ki(3) = atan2(ki_cartesian(2) , ki_cartesian(1))



!Define metric
call calculate_contravariant_metric(r,theta,metric_contra)
call calculate_covariant_metric(r,theta,metric_covar)


!Define emitter 4 velocity
cpt = metric_contra(1,1) + 2.0_dp*metric_contra(1,4) + metric_contra(4,4) 
cpt = sqrt(-1.0_dp/cpt)

!Ensures the normalization is correct
u_covar(1) = cpt
u_covar(2) = 0.0_dp
u_covar(3) = 0.0_dp
u_covar(4) = cpt
u_contra = MATMUL(metric_contra, u_covar)



!Construct some random vector. 
!This vector is in the tetrad frame and so is lowered/raised by Minkowski
k_contra(1) = 0.0_dp
k_contra(2) = ki(1)
k_contra(3) = ki(2)
k_contra(4) = ki(3)


!k_covar(1) = -k_contra(1)
!k_covar(2) = k_contra(2)
!k_covar(3) = k_contra(3)
!k_covar(4) = k_contra(4)



print *, k_contra
call magnitude_minkowski(k_contra, mag1)
print *, mag1
!The size of this vector is
!call magnitude_minkowski(k_contra, mag1)
!print *, 'Vector size in comoving frame', mag1


!call magnitude_minkowski(k_covar, mag1)
!print *, 'Vector size in comoving frame', mag1



!call magnitude(metric_covar, k_contra, mag1)
!print *, mag1
!stop

!Construct matrix to transform to the global (BL) coordinate basis
delta = r**2.0_dp + a**2.0_dp - 2.0_dp*r
N1 = sqrt(- metric_covar(2,2) * (u_covar(1) * u_contra(1) + u_covar(4)*u_contra(4)) * (1.0_dp + u_covar(3)*u_contra(3)) )
N2 = sqrt(metric_covar(3,3) * (1.0_dp + u_covar(3) * u_contra(3)) )
N3 = sqrt(-(u_covar(1) * u_contra(1) + u_covar(4)*u_contra(4))*delta*sin(theta)**2)

transform(1,:) = u_contra

transform(2,1) = u_covar(2)*u_contra(1)/N1 
transform(2,2) = -(u_covar(1) * u_contra(1) + u_covar(4)*u_contra(4))/N1
transform(2,3) = 0.0_dp
transform(2,4) = u_covar(2)*u_contra(4)/N1


transform(3,1) = u_covar(3)*u_contra(1)/N2
transform(3,2) = u_covar(3)*u_contra(2) / N2
transform(3,3) = (1.0_dp + u_covar(3)*u_contra(3))/N2
transform(3,4) = u_covar(3)*u_contra(4)/N2



transform(4,1) = u_covar(4)/N3
transform(4,2) = 0.0_dp
transform(4,3) = 0.0_dp
transform(4,4) = -u_covar(1)/N3






Bmatrix(1,:) = -u_covar

Bmatrix(2,1) = u_covar(2)*u_covar(1)/N1
Bmatrix(2,2) = -metric_covar(2,2)*(u_covar(1)*u_contra(1) + u_covar(4)*u_contra(4))/N1
Bmatrix(2,3) = 0.0_dp
Bmatrix(2,4) = u_covar(2)*u_covar(4)/N1


Bmatrix(3,1) = u_covar(3)*u_covar(1)/N2
Bmatrix(3,2) = u_covar(3)*u_covar(2)/N2
Bmatrix(3,3) = metric_covar(3,3)*(1.0_dp + u_covar(3)*u_contra(3))/N2
Bmatrix(3,4) = u_covar(3)*u_covar(4)/N2


Bmatrix(4,1) = u_contra(4)
Bmatrix(4,2) = 0.0_dp
Bmatrix(4,3) = 0.0_dp
Bmatrix(4,4) = -u_contra(1)

Bmatrix(4,:) = -Bmatrix(4,:) * delta*sin(theta)**2/N3





!Transform to global coordinate frame

k_contra_global = MATMUL(transform, k_contra)



print *, k_contra_global

call magnitude(metric_covar, k_contra_global,mag1)
print *, mag1

stop
!k_covar_global = MATMUL(Bmatrix, k_covar)






print *, 'Checks'
print *, 'Global Vectors:'
print *, k_covar_global
print *, k_contra_global






!print *, 'covar metric'
!print *, metric_covar(1,:)
!print *, metric_covar(2,:)
!print *, metric_covar(3,:)
!print *, metric_covar(4,:)




print *, 'compare'
ii = 3
print *, k_covar_global(ii)
print *, k_contra_global(ii)*metric_covar(ii,ii)



stop



print *, 'sum magnitude'



print *, k_contra_global(1)*k_covar_global(1) &
         + k_contra_global(2)*k_covar_global(2) &
         + k_contra_global(3)*k_covar_global(3) &
         + k_contra_global(4)*k_covar_global(4) 








print *, 'Check Kronekar'
do ii = 1,4
do kk = 1,4

 summation = 0
 do jj = 1,4
 summation = summation + metric_contra(ii,jj)*metric_covar(jj,kk)
 enddo
 print *, ii,kk,summation





 enddo


 enddo








!print *, k_contra_global(ii)
!print *, k_covar_global(1)*metric_contra(1,ii) + & 
 !        k_covar_global(2)*metric_contra(2,ii) + &
  !       k_covar_global(3)*metric_contra(3,ii) + &
   !      k_covar_global(4)*metric_contra(4,ii) 

 
 



!print *, k_contra_global(1) 
!print *, metric_contra(1,1) * k_covar_global(1) + metric_contra(1,4) * k_covar_global(4)


print *, k_contra_global(1)*k_covar_global(1) &
         + k_contra_global(2)*k_covar_global(2) &
         + k_contra_global(3)*k_covar_global(3) &
         + k_contra_global(4)*k_covar_global(4) 



!The magnitude is now given by the full metric
!call magnitude_minkowski(k_contra_global, mag1)
call magnitude(metric_covar, k_contra_global, mag1)
print *, 'Vector size in global frame', mag1


end program main
